#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef pair<int, int> pi;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    // freopen("input.txt", "r", stdin);
    // freopen("output.txt", "w", stdout);

    // std::vector<ТИП_ДАННЫХ> ИМЯ(РАЗМЕР, СТАРТОВОЕ ЗНАЧЕНИЕ)
    std::vector<int, 5> v;
    vector<int> vec = {1, 2, 3, 4};

    // Стандартный ввод и вывод в вектор
    int n;
    cin >> n;
    vector<int> vec(n);
    for (int i = 0; i < n; ++i)
    {
        cin >> vec[i];
    }
    for (int i = 0; i < n; ++i)
    {
        cout << vec[i] << " ";
    }
    for (size_t i = 0; i < vec.size(); ++i)
    {
        cout << vec[i] << " ";
    }

    // Вектор специфические

    v.assign();   // присваивает значения контейнеру
    v.capacity(); // возвращает количество элементов, которые могут храниться в выделенной в данный момент памяти
    v.clear();    // очищает содержимое
    // Функция push_back() принимает в качестве аргумента объект типа значения вектора и добавляет копию объекта в конец вектора. При этом создается новый объект и в него копируется аргумент.
    // Функция emplace(), с другой стороны, конструирует объект на месте в конце вектора. В качестве аргументов она принимает аргументы конструктора объекта и конструирует объект непосредственно в пространстве памяти вектора. Это может быть более эффективно, чем push_back(), поскольку позволяет избежать необходимости в конструкторе копирования или перемещения и сократить количество необходимых выделений памяти.
    v.emplace("John", 30);      // создаёт элемент на месте
    v.emplace_back("John", 30); // создаёт элементы на месте в конце
    v.erase();                  // удаляет элементы
    v.get_allocator();          // возвращает связанный аллокатор
    v.insert();                 // вставляет элементы
    v.pop_back();               // удаляет последний элемент
    v.push_back();              // добавляет элемент в конец
    v.reserve();                // резервирует память
    v.resize();                 // изменяет количество хранимых элементов
    v.shrink_to_fit();          // уменьшает использование памяти за счёт освобождения неиспользуемой памяти

    v.erase(v.begin() + 1);
    v.erase(std::remove_if(v.begin(), v.end(), [](int x)
                           { return x < 10; }),
            v.end());

    // Доступ к элементам
    v.at(1);   // (C++11) предоставляет доступ к указанному элементу с проверкой границ
    v[1];      // Предоставляет доступ к указанному элементу
    v.front(); // Предоставляет доступ к первому элементу
    v.back();  // Предоставляет доступ к последнему элементу
    v.data();  // Прямой доступ к базовому массиву

    // Итераторы
    v.begin();   // возвращает итератор на начало
    v.cbegin();  // возвращает итератор на начало
    v.end();     // возвращает итератор на конец
    v.cend();    // возвращает итератор на конец
    v.rbegin();  // возвращает обратный итератор на начало
    v.crbegin(); // возвращает обратный итератор на начало
    v.rend();    // возвращает обратный итератор на конец
    v.crend();   // возвращает обратный итератор на конец

    // Ёмкость
    v.empty();    // проверяет, пуст ли контейнер
    v.size();     // возвращает количество элементов
    v.max_size(); // возвращает максимально возможное количество элементов

    // Операции
    v.swap(arr1); // меняет местами элементы двух массивов std::vector одинакового размера.

    return 0;
}