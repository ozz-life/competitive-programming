package main

import (
	"fmt"
)

type C chan C

func main() {
	var c = make(C, 1)
	c <- c
	for i := 0; i < 1000; i++ {
		select {
		case <-c:
		case <-c:
			c <- c
		default:
			fmt.Println(i)
			return
		}
	}
}

/////////////////////////////////////////////////////

package main

import (
	"fmt"
)

// Тип C, который является каналом из элементов типа C
type C chan C

func main() {
	// Буферизованный канал длины 1
	var c = make(C, 1)
	
	// посылаем канал в канал
	c <- c
	
	
	for i := 0; i < 1000; i++ {
		// Если два case срабатывают одновременно, выбор между ними рандомный
		// На каждом шаге цикла
		select {
		case <-c: // освободили канал от каналОВ, как только войдёт в этот случай, мы после него обязательно войдём в default
		case <-c: // на этом этапе мы запихиваем канал в канал
			c <- c
			
		default: // сработает если из канала прочитать ничего нельзя
			fmt.Println(i)
			return
		}
	}
}

// конечно type C chan C в начале вводит в интерес, но потом вспоминаешь, что тайп это по сути алиас, а канал, это по сути, структура и type C chan C  сравнимо с type Some []Some ))) (что, кстаи, тоже, забавная вещь )))

type Some []Some
func main() {
	some := make(Some, 0)
	some2 := Some{Some{}, Some{}}
	fmt.Println(some)
	fmt.Println(some2)
}

// а дальше, конечно, надо знать или помнить как селект осуществляет проверку кейсов и что селект это вам не свитч)