#include <bits/stdc++.h>
#include <cmath>
using namespace std;

// Бинарное возведение в степень: http://e-maxx.ru/algo/binary_pow
// Эффективное вычисление чисел Фибоначчи
// Возведение перестановки в k-ую степень
// Быстрое применение набора геометрических операций к точкам
// Количество путей фиксированной длины в графе
// Вариация бинарного возведения в степень: перемножение двух чисел по модулю

int binpow(int a, int n)
{
    int res = 1;
    while (n)
    {
        if (n & 1)
            res *= a;
        a *= a;
        n >>= 1;
    }
    return res;
};
// Возведение в степень по модулю
int modpow(int x, int n, int m)
{
    if (n == 0)
        return 1 % m;
    long long u = modpow(x, n / 2, m);
    u = (u * u) % m;
    if (n % 2 == 1)
        u = (u * x) % m;
    return u;
}

// Показанная ниже функция is_prime проверяет, является ли целое число n
// простым. Она пытается поделить n на все целые числа от 2 до ⌊√n⌋; если ни
// одно из них не является делителем, то n простое.

bool is_prime(int n)
{
    if (n < 2)
        return false;
    for (int x = 2; x * x <= n; ++x)
    {
        if (n % x == 0)
            return false;
    }
    return true;
};

// Следующая функция строит вектор, содержащий разложение n на простые множители.
// Функция делит число n на его простые множители и добавляет их в вектор.
// Процесс заканчивается, когда у n не останется множителей между 2 и ⌊√n⌋.
// Если при этом n > 1, то оно простое и добавляется в качестве последнего множителя.
// Отметим, что каждый простой множитель встречается в этом векторе
// столько раз, какова его степень в разложении n. Например, 12 = 2 2 · 3, по
// этому функция вернет результат [2, 2, 3].
vector<int> factors(int n)
{
    vector<int> f;
    for (int x = 2; x * x <= n; x++)
    {
        while (n % x == 0)
        {
            f.push_back(x);
            n /= x;
        }
    }
    if (n > 1)
        f.push_back(n);
    return f;
};

// https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html
// Решето Эратосфена – это алгоритм предварительной обработки, ко-
// торый строит массив sieve , позволяющий для каждого целого числа от 2
// до n эффективно определить, является ли оно простым. Если x простое, то
// sieve [x] = 0, иначе sieve [x] = 1.

for (int x = 2; x <= n; x++)
{
    if (sieve[x])
        continue;
    for (int u = 2 * x; u <= n; u += x)
    {
        sieve[u] = 1;
    }
};

// Алгоритм Евклида. Наибольшим общим делителем (НОД) целых чисел a и b, gcd(a, b)
// называется наибольшее целое число, которое делит одновременно a и b. Например,
// gcd(30, 12) = 6.
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

//

#include <numeric>
std::gcd(a,b);

// наименьшее общего кратного (НОК) – наименьшего целого чис-
// ла, которое делится одновременно на a и на b; оно обозначается lcm(a, b).
// Формулу
#include <numeric>
std::lcm(a,b);

// Расширенный алгоритм Евклида. Воспользовавшись тождеством gcd(a, b) = gcd(b, a mod b)
tuple<int, int, int> gcd(int a, int b)
{
    if (b == 0)
    {
        return {1, 0, a};
    }
    else
    {
        int x, y, g;
        tie(x, y, g) = gcd(b, a % b);
        return {y, x - (a / b) * y, g};
    }
}

int x, y, g;
tie(x, y, g) = gcd(30, 12);
cout << x << " " << y << " " << g << "\n"; // 1 -2 6

// Два целых числа a и b называются взаимно простыми, если gcd(a, b) = 1.
// Функция Эйлера φ(n) определяет количество целых чисел от 1 до n, взаимно
// простых с n. Например, φ(10) = 4, потому что числа 1, 3, 7 и 9 взаимно
// просты с 10.
// https://e-maxx.ru/algo/euler_function
// https://cp-algorithms.com/algebra/phi-function.html
// Простейшая за O(корень из n), существуют значительно более быстрые:
// https://e-maxx.ru/algo/factorization
int euler_phi(int n)
{
    int result = n;
    for (int i = 2; i * i <= n; i++)
    {
        if (n % i == 0)
        {
            while (n % i == 0)
                n /= i;
            result -= result / i;
        }
    }
    if (n > 1)
        result -= result / n;
    return result;
}

////////////////////////////////////////////////////////////////////////////////

// Диофантовы уравнения. Диофантовым уравнением называется уравнение вида
// ax + by = c. Олимпиадное программирование 2020 Antti, страница 180
// https://e-maxx.ru/algo/diofant_2_equation

////////////////////////////////////////////////////////////////////////////////

// Китайская теорема об остатках. Эта теорема касается решения систе-
// мы уравнений вида
// x = a 1 mod m 1
// x = a 2 mod m 2
// ...
// x = a n mod m n
// где числа m 1 , m 2 , ..., m n попарно взаимно простые.
// https://e-maxx.ru/algo/chinese_theorem

////////////////////////////////////////////////////////////////////////////////

// От Славы Муравьёва - https://drive.google.com/drive/folders/1QNqkg9E_9ChTJydRHJxUocFKvM-FXafy